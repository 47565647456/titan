@page "/players"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Orleans
@using Titan.Abstractions.Grains
@using Titan.Abstractions.Models
@using Titan.Dashboard.Services
@attribute [Authorize(Policy = "Viewer")]
@inject IClusterClient ClusterClient
@inject AccountQueryService AccountQuery
@inject ILogger<Players> Logger

<PageTitle>Players - Titan Admin</PageTitle>

<div class="page-container">
    <div class="page-header">
        <h1>üë• Players</h1>
        <p class="subtitle">View and manage player accounts</p>
    </div>

    <div class="tabs">
        <button class="tab @(ActiveTab == "list" ? "active" : "")" @onclick='() => ActiveTab = "list"'>
            üìã All Accounts
        </button>
        <button class="tab @(ActiveTab == "search" ? "active" : "")" @onclick='() => ActiveTab = "search"'>
            üîç Search
        </button>
    </div>

    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="alert alert-danger">@ErrorMessage</div>
    }

    @if (!string.IsNullOrEmpty(SuccessMessage))
    {
        <div class="alert alert-success">@SuccessMessage</div>
    }

    @if (ActiveTab == "list")
    {
        <div class="actions-bar">
            <AuthorizeView Policy="Admin">
                <Authorized>
                    <button class="btn btn-primary" @onclick="CreateAccountAsync" disabled="@IsCreating">
                        @(IsCreating ? "Creating..." : "‚ûï Create Account")
                    </button>
                </Authorized>
            </AuthorizeView>
            <button class="btn btn-secondary" @onclick="LoadAllAccountsAsync" disabled="@IsLoading">
                üîÑ Refresh
            </button>
        </div>

        @if (IsLoading)
        {
            <div class="loading">Loading accounts...</div>
        }
        else if (AllAccounts.Count == 0)
        {
            <div class="empty-state">
                <p>No accounts found in the database.</p>
            </div>
        }
        else
        {
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Account ID</th>
                            <th>Last Modified</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var account in AllAccounts)
                        {
                            <tr>
                                <td><code>@account.AccountId</code></td>
                                <td>@account.LastModified.ToString("MMM d, yyyy HH:mm")</td>
                                <td>
                                    <button class="btn btn-small btn-secondary" @onclick="() => ViewAccount(account.AccountId)">View</button>
                                    <AuthorizeView Policy="Admin">
                                        <Authorized>
                                            <button class="btn btn-small btn-danger" @onclick="() => ShowDeleteDialog(account)">Delete</button>
                                        </Authorized>
                                    </AuthorizeView>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
            <p class="text-muted">Showing @AllAccounts.Count accounts (max 1000)</p>
        }
    }
    else
    {
        <div class="search-bar">
            <div class="search-input-group">
                <label>Account ID (GUID)</label>
                <div class="search-row">
                    <input type="text" class="form-control" @bind="SearchAccountId" 
                           placeholder="e.g., 550e8400-e29b-41d4-a716-446655440000" />
                    <button class="btn btn-primary" @onclick="SearchAccountAsync" disabled="@IsSearching">
                        @(IsSearching ? "Searching..." : "üîç Search")
                    </button>
                </div>
            </div>
        </div>
    }

    @* Account Details Section *@
    @if (CurrentAccount != null)
    {
        <div class="player-details">
            <div class="player-card">
                <h2>Account Details</h2>
                <div class="detail-grid">
                    <div class="detail-item">
                        <span class="detail-label">Account ID</span>
                        <code>@CurrentAccount.AccountId</code>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Created</span>
                        <span>@CurrentAccount.CreatedAt.ToString("MMM d, yyyy HH:mm")</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Cosmetics Unlocked</span>
                        <span>@CurrentAccount.UnlockedCosmetics.Count</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Achievements</span>
                        <span>@CurrentAccount.UnlockedAchievements.Count</span>
                    </div>
                </div>
            </div>

            <div class="player-card">
                <h2>Characters (@Characters.Count)</h2>
                @if (Characters.Count == 0)
                {
                    <p class="text-muted">No characters found.</p>
                }
                else
                {
                    <div class="table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Season</th>
                                    <th>Level</th>
                                    <th>Restrictions</th>
                                    <th>Status</th>
                                    <th>Created</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var character in Characters)
                                {
                                    <tr class="@(character.IsDead ? "row-dead" : "")">
                                        <td>@character.Name</td>
                                        <td><code>@character.SeasonId</code></td>
                                        <td>@character.Level</td>
                                        <td>
                                            @if (character.Restrictions != CharacterRestrictions.None)
                                            {
                                                @foreach (var restriction in GetRestrictionBadges(character.Restrictions))
                                                {
                                                    <span class="badge badge-restriction">@restriction</span>
                                                }
                                            }
                                            else
                                            {
                                                <span class="text-muted">None</span>
                                            }
                                        </td>
                                        <td>
                                            @if (character.IsDead)
                                            {
                                                <span class="badge badge-dead">‚ò†Ô∏è Dead</span>
                                            }
                                            else
                                            {
                                                <span class="badge badge-alive">‚úÖ Alive</span>
                                            }
                                        </td>
                                        <td>@character.CreatedAt.ToString("MMM d, yyyy")</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }
            </div>

            @if (CurrentAccount.UnlockedCosmetics.Count > 0)
            {
                <div class="player-card">
                    <h2>Unlocked Cosmetics</h2>
                    <div class="tag-list">
                        @foreach (var cosmetic in CurrentAccount.UnlockedCosmetics)
                        {
                            <span class="tag">@cosmetic</span>
                        }
                    </div>
                </div>
            }

            @if (CurrentAccount.UnlockedAchievements.Count > 0)
            {
                <div class="player-card">
                    <h2>Achievements</h2>
                    <div class="tag-list">
                        @foreach (var achievement in CurrentAccount.UnlockedAchievements)
                        {
                            <span class="tag tag-achievement">üèÜ @achievement</span>
                        }
                    </div>
                </div>
            }
        </div>
    }
    else if (HasSearched && ActiveTab == "search")
    {
        <div class="empty-state">
            <p>No account found with that ID.</p>
        </div>
    }

    @* Delete Confirmation Modal *@
    @if (ShowDeleteConfirm)
    {
        <div class="modal-overlay" @onclick="CloseDeleteDialog">
            <div class="modal-content modal-small" @onclick:stopPropagation="true">
                <h2>‚ö†Ô∏è Delete Account</h2>
                <p>Are you sure you want to delete account:</p>
                <p><code>@DeleteTarget?.AccountId</code></p>
                <p class="text-muted">This will permanently remove the account data. This action cannot be undone.</p>
                
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" @onclick="CloseDeleteDialog">Cancel</button>
                    <button type="button" class="btn btn-danger" @onclick="DeleteAccountAsync" disabled="@IsDeleting">
                        @(IsDeleting ? "Deleting..." : "Delete")
                    </button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private string ActiveTab { get; set; } = "list";
    private string SearchAccountId { get; set; } = "";
    private bool IsLoading { get; set; }
    private bool IsSearching { get; set; }
    private bool HasSearched { get; set; }
    private bool ShowDeleteConfirm { get; set; }
    private bool IsDeleting { get; set; }
    private bool IsCreating { get; set; }
    private string? ErrorMessage { get; set; }
    private string? SuccessMessage { get; set; }
    
    private List<AccountSummary> AllAccounts { get; set; } = new();
    private Titan.Abstractions.Models.Account? CurrentAccount { get; set; }
    private List<CharacterSummary> Characters { get; set; } = new();
    private AccountSummary? DeleteTarget { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadAllAccountsAsync();
    }

    private async Task LoadAllAccountsAsync()
    {
        IsLoading = true;
        ErrorMessage = null;
        SuccessMessage = null;
        
        try
        {
            AllAccounts = await AccountQuery.GetAllAccountsAsync();
            Logger.LogInformation("Loaded {Count} accounts", AllAccounts.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load accounts");
            ErrorMessage = $"Failed to load accounts: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task CreateAccountAsync()
    {
        IsCreating = true;
        ErrorMessage = null;
        SuccessMessage = null;

        try
        {
            // Generate a new unique account ID
            var newAccountId = Guid.NewGuid();
            
            // Access the grain - this will create it on first access
            var grain = ClusterClient.GetGrain<IAccountGrain>(newAccountId);
            
            // Call GetAccountAsync to ensure the grain is activated and state is persisted
            var account = await grain.GetAccountAsync();
            
            SuccessMessage = $"Account created successfully! ID: {newAccountId}";
            Logger.LogInformation("Created new account {AccountId}", newAccountId);
            
            // Refresh the account list
            await LoadAllAccountsAsync();
            
            // Navigate to view the new account
            await ViewAccount(newAccountId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to create account");
            ErrorMessage = $"Failed to create account: {ex.Message}";
        }
        finally
        {
            IsCreating = false;
        }
    }

    private async Task ViewAccount(Guid accountId)
    {
        ActiveTab = "search";
        SearchAccountId = accountId.ToString();
        await SearchAccountAsync();
    }

    private async Task SearchAccountAsync()
    {
        if (string.IsNullOrWhiteSpace(SearchAccountId))
        {
            ErrorMessage = "Please enter an Account ID";
            return;
        }

        if (!Guid.TryParse(SearchAccountId.Trim(), out var accountId))
        {
            ErrorMessage = "Invalid Account ID format. Please enter a valid GUID.";
            return;
        }

        IsSearching = true;
        ErrorMessage = null;
        SuccessMessage = null;
        HasSearched = false;
        CurrentAccount = null;
        Characters.Clear();

        try
        {
            var grain = ClusterClient.GetGrain<IAccountGrain>(accountId);
            CurrentAccount = await grain.GetAccountAsync();
            
            if (CurrentAccount != null && CurrentAccount.AccountId != Guid.Empty)
            {
                var chars = await grain.GetCharactersAsync();
                Characters = chars.OrderByDescending(c => c.CreatedAt).ToList();
                HasSearched = true;
                Logger.LogInformation("Found account {AccountId} with {CharacterCount} characters", accountId, Characters.Count);
            }
            else
            {
                CurrentAccount = null;
                HasSearched = true;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to search for account {AccountId}", accountId);
            ErrorMessage = $"Error searching for account: {ex.Message}";
            HasSearched = true;
        }
        finally
        {
            IsSearching = false;
        }
    }

    private void ShowDeleteDialog(AccountSummary account)
    {
        DeleteTarget = account;
        ShowDeleteConfirm = true;
    }

    private void CloseDeleteDialog()
    {
        ShowDeleteConfirm = false;
        DeleteTarget = null;
    }

    private async Task DeleteAccountAsync()
    {
        if (DeleteTarget == null) return;
        
        IsDeleting = true;
        
        try
        {
            var deleted = await AccountQuery.DeleteAccountAsync(DeleteTarget.AccountId);
            
            if (deleted)
            {
                SuccessMessage = $"Account {DeleteTarget.AccountId} deleted successfully.";
                Logger.LogInformation("Deleted account {AccountId}", DeleteTarget.AccountId);
            }
            else
            {
                ErrorMessage = "Account not found or already deleted.";
            }
            
            CloseDeleteDialog();
            CurrentAccount = null;
            Characters.Clear();
            await LoadAllAccountsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to delete account {AccountId}", DeleteTarget?.AccountId);
            ErrorMessage = $"Failed to delete account: {ex.Message}";
        }
        finally
        {
            IsDeleting = false;
        }
    }

    private static IEnumerable<string> GetRestrictionBadges(CharacterRestrictions restrictions)
    {
        if (restrictions.HasFlag(CharacterRestrictions.Hardcore))
            yield return "Hardcore";
        if (restrictions.HasFlag(CharacterRestrictions.SoloSelfFound))
            yield return "SSF";
    }
}
